<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CHIPS:// Browser & Quantum Node</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <style>
        body { font-family: 'Poppins', sans-serif; background-color: #0f172a; color: #e5e7eb; }
        .grid-container { display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; }
        .console { background-color: #1e293b; font-family: monospace; height: 200px; overflow-y: auto; border-radius: 0.5rem; padding: 1rem; }
        .btn { background: #3b82f6; color: white; border: none; padding: 0.6rem 1.2rem; border-radius: 8px; font-weight: 500; cursor: pointer; transition: all 0.2s ease; }
        canvas { background-color: #1e293b; border: 1px solid #334155; border-radius: 0.75rem; display: block; }
        .game-over-message { display: none; } /* Hide game over by default */
    </style>
</head>
<body class="p-6">
    <div class="max-w-7xl mx-auto space-y-6">
        <header>
            <h1 class="text-3xl font-bold">CHIPS:// Browser & Quantum Node</h1>
            <p id="connection-status" class="text-red-500">Connecting to Back Office...</p>
        </header>

        <div class="grid-container">
            <!-- Left Column: Game -->
            <div class="space-y-6">
                <section>
                    <h2 class="text-xl font-semibold mb-3">Quantum Entangled Snake</h2>
                    <canvas id="gameCanvas" width="400" height="400"></canvas>
                    <div class="mt-4">
                        <button id="findGameBtn" class="btn bg-green-600">Find Entangled Partner</button>
                    </div>
                </section>
            </div>

            <!-- Right Column: Log -->
            <div class="space-y-6">
                <section><h2 class="text-xl font-semibold mb-3">Node Log</h2><div id="nodeLog" class="console"></div></section>
            </div>
        </div>
    </div>

<script>
    const nodeLog = document.getElementById('nodeLog');
    const connectionStatus = document.getElementById('connection-status');
    const findGameBtn = document.getElementById('findGameBtn');
    const gameCanvas = document.getElementById('gameCanvas');
    const ctx = gameCanvas.getContext('2d');
    
    // --- Socket.IO Connection ---
    const socket = io("https://qios-2.onrender.com", { transports: ['websocket'] });

    function log(m, t='info'){ /* ... same as before ... */ }
    socket.on('connect', () => { /* ... same as before ... */ });
    socket.on('ping', () => { socket.emit('pong'); });
    socket.on('disconnect', () => { /* ... same as before ... */ });
    socket.on('log_message', (data) => { log(data.message, data.type); });

    // --- SNAKE GAME LOGIC ---
    const tileSize = 20;
    let snake = [];
    let food = {};
    let direction = 'right';
    let gameLoop;
    let isGameOver = false;

    function generateFood() {
        food = {
            x: Math.floor(Math.random() * (gameCanvas.width / tileSize)),
            y: Math.floor(Math.random() * (gameCanvas.height / tileSize))
        };
    }

    function draw() {
        ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
        ctx.fillStyle = '#f6ad55'; // Food color
        ctx.fillRect(food.x * tileSize, food.y * tileSize, tileSize, tileSize);
        ctx.fillStyle = '#63b3ed'; // Snake color
        snake.forEach(segment => {
            ctx.fillRect(segment.x * tileSize, segment.y * tileSize, tileSize, tileSize);
        });
    }

    function update() {
        if (isGameOver) return;
        const head = {x: snake[0].x, y: snake[0].y};
        switch (direction) {
            case 'right': head.x++; break;
            case 'left': head.x--; break;
            case 'up': head.y--; break;
            case 'down': head.y++; break;
        }
        snake.unshift(head);

        // Check for collision with food
        if (head.x === food.x && head.y === food.y) {
            log('Ate food! Notifying partner...', 'info');
            socket.emit('ate_food'); // ** NOTIFY SERVER **
            generateFood();
        } else {
            snake.pop();
        }
        
        // Game over conditions
        if (head.x < 0 || head.x >= gameCanvas.width / tileSize || head.y < 0 || head.y >= gameCanvas.height / tileSize) {
            endGame();
        }
        draw();
    }

    function startGame() {
        snake = [{x: 10, y: 10}];
        direction = 'right';
        isGameOver = false;
        generateFood();
        clearInterval(gameLoop);
        gameLoop = setInterval(update, 120);
        log('Game started!', 'success');
        findGameBtn.disabled = true;
    }

    function endGame() {
        clearInterval(gameLoop);
        isGameOver = true;
        log('Game Over! Your snake collided.', 'error');
        findGameBtn.disabled = false;
    }

    document.addEventListener('keydown', (e) => {
        switch (e.key) {
            case 'ArrowUp': if (direction !== 'down') direction = 'up'; break;
            case 'ArrowDown': if (direction !== 'up') direction = 'up'; break; // Fixed bug
            case 'ArrowLeft': if (direction !== 'right') direction = 'left'; break;
            case 'ArrowRight': if (direction !== 'left') direction = 'right'; break;
        }
    });

    findGameBtn.addEventListener('click', () => {
        log('Finding an entangled partner...', 'info');
        socket.emit('find_game');
    });

    // --- NEW: Game Event Listeners from Server ---
    socket.on('game_start', (data) => {
        log(`Partner found: ${data.partnerId.substring(0,6)}... Entanglement established!`, 'success');
        startGame();
    });

    socket.on('entangled_growth', () => {
        log('Received entangled growth command from partner!', 'warn');
        // Grow snake without eating food by not calling snake.pop()
        // We can just add a tail segment to make it simple
        const tail = snake[snake.length - 1];
        snake.push({...tail}); // Add a new segment at the tail's last position
    });
    
    // Initial draw
    draw();
</script>
</body>
</html>
