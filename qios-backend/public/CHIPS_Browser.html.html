<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CHIPS:// Browser & Quantum Node</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <style>
        body { font-family: 'Poppins', sans-serif; background-color: #0f172a; color: #e5e7eb; }
        .grid-container { display: grid; grid-template-columns: 1fr 1.5fr; gap: 1.5rem; }
        .console { background-color: #1e293b; font-family: monospace; height: 400px; overflow-y: auto; border-radius: 0.5rem; padding: 1rem; }
        .btn { background: #3b82f6; color: white; border: none; padding: 0.6rem 1.2rem; border-radius: 8px; font-weight: 500; cursor: pointer; transition: all 0.2s ease; }
        canvas { background-color: #1e293b; border: 1px solid #334155; border-radius: 0.75rem; display: block; touch-action: none; }
        textarea { background: #1e293b; border: 1px solid #334155; color: #e5e7eb; border-radius: 8px; }
    </style>
</head>
<body class="p-6">
    <div class="max-w-7xl mx-auto space-y-6">
        <header>
            <h1 class="text-3xl font-bold">CHIPS:// Browser & Quantum Node</h1>
            <p id="connection-status" class="text-red-500">Connecting to Back Office...</p>
        </header>
        <div class="grid-container">
            <div class="space-y-6">
                <section>
                    <h2 class="text-xl font-semibold mb-3">Quantum Program IDE</h2>
                    <textarea id="programEditor" class="w-full h-64 p-3 font-mono text-sm"></textarea>
                    <div class="flex space-x-2 mt-2">
                        <button id="runProgramBtn" class="btn">Run Program (Orchestrated)</button>
                        <button id="loadExampleBtn" class="btn bg-gray-600">Load Teleportation Prep</button>
                    </div>
                     <div class="mt-4">
                        <button id="loadAiTestBtn" class="btn bg-yellow-600">Load AI Alert Test Program</button>
                    </div>
                </section>
                <section>
                    <h2 class="text-xl font-semibold mb-3">Node Log</h2>
                    <div id="nodeLog" class="console"></div>
                </section>
            </div>
            <div class="space-y-6">
                <section>
                    <h2 class="text-xl font-semibold mb-3">Local Qubit Simulator</h2>
                    <canvas id="quantumCanvas" class="w-full aspect-video"></canvas>
                </section>
            </div>
        </div>
    </div>

<script>
    const programEditor = document.getElementById('programEditor');
    const runProgramBtn = document.getElementById('runProgramBtn');
    const loadExampleBtn = document.getElementById('loadExampleBtn');
    const loadAiTestBtn = document.getElementById('loadAiTestBtn');
    const nodeLog = document.getElementById('nodeLog');
    const connectionStatus = document.getElementById('connection-status');
    const canvas = document.getElementById('quantumCanvas');
    const ctx = canvas.getContext('2d');

    let particles = [];
    let particleNameMap = new Map();

    class Complex {
        constructor(re, im) { this.re = re; this.im = im; }
        add(other) { return new Complex(this.re + other.re, this.im + other.im); }
        sub(other) { return new Complex(this.re - other.re, this.im - other.im); }
        mul(other) { return new Complex(this.re * other.re - this.im * other.im, this.re * other.im + this.im * other.re); }
        magnitudeSq() { return this.re * this.re + this.im * this.im; }
    }
    class QuantumParticle {
        constructor(name) {
            this.name = name; this.x = Math.random() * (canvas.width-80)+40; this.y = Math.random() * (canvas.height-80)+40;
            this.radius = 20; this.alpha = new Complex(1, 0); this.beta = new Complex(0, 0); this.measuredValue = 0; this.isEntangled = false;
        }
        applyHadamard() { const a=this.alpha, b=this.beta; const s=new Complex(1/Math.sqrt(2),0); this.alpha=a.add(b).mul(s); this.beta=a.sub(b).mul(s); this.measuredValue=null; }
        applyPauliX() { [this.alpha, this.beta] = [this.beta, this.alpha]; this.measuredValue=null; }
        applyPauliZ() { this.beta = this.beta.mul(new Complex(-1, 0)); this.measuredValue=null; }
        measure() {
            const prob0 = this.alpha.magnitudeSq(); const outcome = Math.random() < prob0 ? 0 : 1;
            this.measuredValue = outcome; this.alpha = new Complex(outcome===0?1:0,0); this.beta = new Complex(outcome===1?1:0,0); return outcome;
        }
        getStateString() { if (this.measuredValue !== null) return `|${this.measuredValue}>`; const p0=(this.alpha.magnitudeSq()*100).toFixed(1), p1=(this.beta.magnitudeSq()*100).toFixed(1); return `(${p0}%|0>, ${p1}%|1>)`; }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        particles.forEach(p => {
            if (p.isEntangled) {
                ctx.beginPath(); ctx.moveTo(p.x, p.y);
                ctx.lineTo(p.x > canvas.width / 2 ? canvas.width + 50 : -50, p.y);
                ctx.strokeStyle = "rgba(0, 242, 234, 0.5)"; ctx.lineWidth = 2; ctx.setLineDash([5, 15]); ctx.stroke(); ctx.setLineDash([]);
            }
        });
        particles.forEach(p => {
            ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
            if (p.measuredValue === 0) ctx.fillStyle = '#3b82f6'; else if (p.measuredValue === 1) ctx.fillStyle = '#ef4444';
            else { const r = Math.floor(255*p.beta.magnitudeSq()); const b = Math.floor(255*p.alpha.magnitudeSq()); ctx.fillStyle = `rgb(${r}, 100, ${b})`; }
            ctx.fill(); ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.font = 'bold 12px Poppins';
            ctx.fillText(p.name, p.x, p.y - p.radius - 8); ctx.font = '10px Poppins'; ctx.fillText(p.getStateString(), p.x, p.y + p.radius + 12);
        });
    }

    function addParticle(name) { if (!particleNameMap.has(name)) { const p=new QuantumParticle(name); particles.push(p); particleNameMap.set(name, p); log(`Particle "${name}" created.`, 'info'); draw(); }}
    function getParticle(name) { return particleNameMap.get(name); }
    
    const socket = io("https://qios-2.onrender.com");

    function log(message, type = 'info') { const p = document.createElement('p'); p.textContent = `[${new Date().toLocaleTimeString()}] ${message}`; if (type === 'error') p.className = 'text-red-400'; else if (type === 'warn') p.className = 'text-yellow-400'; else p.className = 'text-cyan-400'; nodeLog.appendChild(p); nodeLog.scrollTop = nodeLog.scrollHeight; }

    socket.on('connect', () => { connectionStatus.textContent = `Connected. Node ID: ${socket.id.substring(0,6)}...`; connectionStatus.className = 'text-green-500'; log('Successfully connected to QIOS Back Office.', 'info'); socket.emit('register_node'); });
    socket.on('ping', () => { socket.emit('pong'); });
    socket.on('disconnect', () => { connectionStatus.textContent = 'Disconnected'; connectionStatus.className = 'text-red-500'; log('Connection lost.', 'error'); });
    socket.on('log_message', (data) => { log(data.message, data.type); });

    socket.on('execute_command', (data) => {
        log(`Received command: ${data.command} on ${data.target}`, 'warn');
        let particle = getParticle(data.target);
        switch (data.command) {
            case 'create_particle': addParticle(data.target); break;
            case 'hadamard': if (particle) particle.applyHadamard(); break;
            case 'x': if (particle) particle.applyPauliX(); break;
            case 'z': if (particle) particle.applyPauliZ(); break;
            case 'entangle': if (particle) particle.isEntangled = true; break;
            case 'measure':
                if (particle) {
                    const result = particle.measure();
                    socket.emit(`measure_result_${data.bit}`, { result: result });
                    log(`Measured ${particle.name}, result is ${result}. Sent to server.`, 'info');
                }
                break;
        }
        draw();
    });

    runProgramBtn.addEventListener('click', () => {
        const programCode = programEditor.value; if (!programCode) return;
        particles = []; particleNameMap.clear(); draw();
        log('Sending program to Back Office for orchestration...', 'info');
        socket.emit('run_program', { code: programCode });
    });
    
    const teleportPrepCode = `// Creates an entangled pair (Bell State) and a third particle\n// with a state to be teleported (superposition).\n\nparticle q_source;\nparticle q_alice;\nparticle q_bob;\n\nhadamard q_source;\nx q_source;\n\nhadamard q_alice;\ncnot q_alice, q_bob;`;
    loadExampleBtn.addEventListener('click', () => { programEditor.value = teleportPrepCode; log('Quantum Teleportation prep program loaded.', 'info'); });
    
    const aiTestCode = `particle attacker_q1;\nmeasure attacker_q1 -> c1;\nmeasure attacker_q1 -> c2;\nmeasure attacker_q1 -> c3;\nmeasure attacker_q1 -> c4;\nmeasure attacker_q1 -> c5;\nmeasure attacker_q1 -> c6;`;
    loadAiTestBtn.addEventListener('click', () => { programEditor.value = aiTestCode; log('AI alert test program loaded.', 'info'); });
    
    window.onresize = () => { canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight; draw(); };
    window.onload = () => { window.onresize(); };
</script>
</body>
</html>